package com.game.weichi;

import android.content.Context;
import android.content.res.Resources;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.view.View;

public class WeiChiView extends View{

	protected static int GRID_SIZE = 10;
    protected static int GRID_WIDTH = 30; 
    protected static int CHESS_DIAMETER = 26; 
    protected static int mStartX=0;// 
    protected static int mStartY=0;// 
    private Bitmap[] mChessBW; // 
    private static int[][] mGridArray; 
    private final int BLACK=1;
    private final int WHITE=2;
	public WeiChiView(Context context, AttributeSet attrs) {
		super(context, attrs);
		
	}
	 public WeiChiView(Context context, AttributeSet attrs, int defStyle) {
	    	super(context, attrs, defStyle);
	    	 this.setFocusable(true);  //20090530
	         this.setFocusableInTouchMode(true);
	        
	         init();

	    }

	 protected void onSizeChanged(int w, int h, int oldw, int oldh) {
	        mStartX = w / 2 - GRID_SIZE * GRID_WIDTH / 2;
	        mStartY = h / 2 - GRID_SIZE * GRID_WIDTH / 2;
	    }
	 public void init() {
	       
	        mGridArray = new int[GRID_SIZE-1][GRID_SIZE-1];
	       
	        mChessBW = new Bitmap[2];

	        Bitmap bitmap = Bitmap.createBitmap(CHESS_DIAMETER, CHESS_DIAMETER, Bitmap.Config.ARGB_8888);
	        Canvas canvas = new Canvas(bitmap);
	        Resources r = this.getContext().getResources();

	        Drawable tile = r.getDrawable(R.drawable.chess1);
	        tile.setBounds(0, 0, CHESS_DIAMETER, CHESS_DIAMETER);
	        tile.draw(canvas);
	        mChessBW[0] = bitmap;

	        tile = r.getDrawable(R.drawable.chess2);
	        tile.setBounds(0, 0, CHESS_DIAMETER, CHESS_DIAMETER);
	        tile.draw(canvas);
	        mChessBW[1] = bitmap;
	  }

	    
	
	 
   public void ondraw(Canvas canvas)
   {      super.onDraw(canvas);

	   canvas.drawColor(Color.YELLOW);	
	   {
           Paint paintRect = new Paint();
           paintRect.setColor(Color.GRAY);
           paintRect.setStrokeWidth(2);
           paintRect.setStyle(Style.STROKE);

           for (int i = 0; i < GRID_SIZE; i++) {
               for (int j = 0; j < GRID_SIZE; j++) {
            	   int mLeft = i * GRID_WIDTH + mStartX;
                   int mTop = j * GRID_WIDTH + mStartY;
                   int mRright = mLeft + GRID_WIDTH;
                   int mBottom = mTop + GRID_WIDTH;
                   canvas.drawRect(mLeft, mTop, mRright, mBottom, paintRect);
               }
           }
          
         
           paintRect.setStrokeWidth(4);
           canvas.drawRect(mStartX, mStartY, mStartX + GRID_WIDTH*GRID_SIZE, mStartY + GRID_WIDTH*GRID_SIZE, paintRect);
       }
	   
	   for (int i = 0; i < GRID_SIZE-1; i++) {
           for (int j = 0; j < GRID_SIZE-1; j++) {
               if(mGridArray[i][j] == BLACK){
                   
                   //canvas.drawBitmap(mChessBW[0], mStartX + (i+1) * GRID_WIDTH - CHESS_DIAMETER/2 , mStartY + (j+1)* GRID_WIDTH - CHESS_DIAMETER/2 , mPaint);
                  
                
                    {
                       Paint paintCircle = new Paint();
                       paintCircle.setColor(Color.BLACK);
                       canvas.drawCircle(mStartX + (i+1) * GRID_WIDTH, mStartY + (j+1)* GRID_WIDTH, CHESS_DIAMETER/2, paintCircle);
                   }
                  
               }else if(mGridArray[i][j] == WHITE){
                  
                   //canvas.drawBitmap(mChessBW[1], mStartX + (i+1) * GRID_WIDTH - CHESS_DIAMETER/2 , mStartY + (j+1)* GRID_WIDTH - CHESS_DIAMETER/2 , mPaint);
                  
              
                   {
                       Paint paintCircle = new Paint();
                       paintCircle.setColor(Color.WHITE);
                       canvas.drawCircle(mStartX + (i+1) * GRID_WIDTH, mStartY + (j+1)* GRID_WIDTH, CHESS_DIAMETER/2, paintCircle);
                   }
               }
           }
       }
   }
	   
   }
}


